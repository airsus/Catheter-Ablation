{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"get",
				"get_xy_coords"
			],
			[
				"unshaped_exp",
				"unshaped_exp_response"
			],
			[
				"zvic_exp",
				"zvic_exp_response"
			],
			[
				"des",
				"des_luff"
			],
			[
				"siic",
				"siic_amp_interp"
			],
			[
				"zvic_amp",
				"zvic_amp_interp"
			],
			[
				"Y",
				"Y2_LABEL"
			],
			[
				"Y_M",
				"Y_MIN"
			],
			[
				"T",
				"TRANSPARENT"
			],
			[
				"tr",
				"trolley_image"
			],
			[
				"freq",
				"freq_hz"
			],
			[
				"Pay",
				"PAYLOAD_OFFSET"
			],
			[
				"OFF",
				"ORIGN_OFFSET"
			],
			[
				"scur",
				"scurve_shaper"
			],
			[
				"modeled",
				"modeled_step_deriv"
			],
			[
				"troll",
				"trolley_offset_y"
			],
			[
				"trolley_",
				"trolley_offset_x"
			],
			[
				"trolley_offset",
				"trolley_offset_y"
			],
			[
				"trolley",
				"trolley_offset_x"
			],
			[
				"unshaped_exp_",
				"unshaped_exp_angle"
			],
			[
				"smooth_",
				"smooth_polyshape"
			],
			[
				"start",
				"startstep_time"
			],
			[
				"siic_exp",
				"siic_exp_response"
			],
			[
				"unshaped",
				"unshaped_exp_times"
			],
			[
				"unshape",
				"unshaped_exp_times"
			],
			[
				"newman",
				"newman_command"
			],
			[
				"const",
				"constraints"
			],
			[
				"rotated",
				"rotated_coords"
			],
			[
				"rotate",
				"rotated_coords"
			],
			[
				"kalman",
				"kalman_estimate"
			],
			[
				"kalm",
				"kalman_gain"
			],
			[
				"C_lower",
				"C_lowerright"
			],
			[
				"thetadot",
				"theta0dot_z"
			],
			[
				"ss_re",
				"ss_response_deriv"
			],
			[
				"marker",
				"marker_weight"
			],
			[
				"imag",
				"imag_roots"
			],
			[
				"opt",
				"opt_condition"
			],
			[
				"Tacc",
				"Tacc_array"
			],
			[
				"percent",
				"percent_settle"
			],
			[
				"subo",
				"subopt_shaper"
			],
			[
				"Omegas",
				"Omegas_damp"
			],
			[
				"K_",
				"K_damped"
			],
			[
				"Zeta",
				"Zeta_cons"
			],
			[
				"thetad",
				"thetad_dot"
			],
			[
				"x0",
				"x0_dot"
			],
			[
				"theta0",
				"theta0_dot"
			],
			[
				"diff",
				"diff_metric"
			],
			[
				"sub_shaped",
				"sub_shaped_effort1"
			],
			[
				"subopt_",
				"subopt_shaper2"
			],
			[
				"subopt",
				"subopt_shaper1"
			],
			[
				"subop",
				"subopt_shaper1"
			],
			[
				"o",
				"opt_condition"
			],
			[
				"max",
				"max_gains"
			],
			[
				"nat_Fre",
				"nat_freq_to_total"
			],
			[
				"tau",
				"tau_max"
			],
			[
				"tua",
				"tau_max"
			],
			[
				"t_",
				"t_step"
			],
			[
				"unshaped_theta",
				"unshaped_theta1_vel"
			],
			[
				"parameter",
				"parameter_vals"
			],
			[
				"nat_freq",
				"nat_freq_to_total"
			],
			[
				"damp_",
				"damp_to_total"
			],
			[
				"set",
				"set_trace"
			],
			[
				"desired",
				"desired_end"
			],
			[
				"shaped",
				"shaped_effort2"
			],
			[
				"gain",
				"gain_multiplier"
			],
			[
				"g",
				"gain_multiplier"
			],
			[
				"m",
				"m_2"
			],
			[
				"phi_1",
				"phi_1_prime"
			],
			[
				"phi_2",
				"phi_2_prime"
			],
			[
				"delta22",
				"delta22_dot"
			],
			[
				"v_mom",
				"v_2_moment"
			],
			[
				"w_",
				"w_2_moment"
			],
			[
				"w_momen",
				"w_1_moment"
			],
			[
				"feed",
				"feedback_step"
			],
			[
				"ic_init",
				"ic_init_vel"
			],
			[
				"ic",
				"ic_ampshift"
			],
			[
				"tacc_",
				"tacc_norm"
			],
			[
				"t",
				"tacc_step"
			],
			[
				"line",
				"linear_response"
			],
			[
				"top",
				"top-to-bottom"
			],
			[
				"shifted",
				"shifted_amp"
			],
			[
				"dig",
				"dig_shaper"
			],
			[
				"design",
				"design_freq"
			],
			[
				"desig",
				"design_freq"
			],
			[
				"tacc",
				"tacc"
			],
			[
				"pause",
				"pause_duration_step"
			],
			[
				"shaper",
				"shaper_amps"
			],
			[
				"the",
				"theta_2_diff"
			],
			[
				"pulse",
				"pulse_response"
			],
			[
				"impulse",
				"impulse_response"
			],
			[
				"de",
				"detected_phase"
			],
			[
				"modeled_",
				"modeled_freq"
			],
			[
				"ic_in",
				"ic_init_pos"
			],
			[
				"rand",
				"randnum_counter"
			],
			[
				"binary",
				"binary_genome"
			],
			[
				"rand_",
				"rand_numbers"
			],
			[
				"deltaE_a",
				"Delta_E_Avg"
			],
			[
				"print",
				"print_rand_l_boltz"
			],
			[
				"rand_nums",
				"rand_nums_used"
			],
			[
				"fitn",
				"fitness_fraction"
			],
			[
				"num",
				"num_variables"
			],
			[
				"se",
				"set_trace"
			],
			[
				"A",
				"Absolute"
			],
			[
				"pop",
				"pop_num"
			],
			[
				"norm",
				"normalized_acc"
			],
			[
				"Startt",
				"Startt"
			],
			[
				"delta",
				"delta_gamma"
			],
			[
				"kp",
				"kp_guess_shaped"
			],
			[
				"p",
				"peak_effort"
			],
			[
				"k",
				"k_d"
			],
			[
				"ze",
				"zeta_omega_1"
			],
			[
				"m1_",
				"m1_disturbance"
			],
			[
				"real",
				"real_kp100"
			],
			[
				"t_shaper",
				"t_shaper_2"
			],
			[
				"step",
				"step_input"
			],
			[
				"obj",
				"obj_deriv"
			],
			[
				"ob",
				"obj_deriv"
			],
			[
				"omeg",
				"omega_n_hz"
			],
			[
				"tick",
				"tick_increment"
			],
			[
				"Start",
				"StartTime"
			],
			[
				"shap",
				"shaped_step_response"
			],
			[
				"optimi",
				"optimized_input"
			],
			[
				"exp",
				"experimental_args"
			],
			[
				"desi",
				"design_freq"
			],
			[
				"mod",
				"modeled_freq"
			],
			[
				"siic_end",
				"siic_end_input"
			],
			[
				"zvic",
				"zvic_deleting_indexes"
			],
			[
				"delay",
				"delay_steps"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "# Sympy libraries to symbolically create system models\nfrom sympy import symbols\nfrom sympy.physics import mechanics\nfrom sympy.physics.mechanics import dynamicsymbols\nimport sympy.physics.mechanics as me\nfrom sympy.physics.mechanics import inertia\nfrom sympy import Dummy, lambdify\nfrom sympy import Matrix\n\n# Scipy libraries to optimize and integrate\nfrom scipy import integrate\nfrom scipy.integrate import odeint\nfrom scipy.optimize import minimize\n\n# Numpy library to perform computational heavy lifting\nimport numpy as np\n\ndef derive_sys(n,p):\n    \"\"\"\n    Derive the equations of motion using Kane's method\n    \n    Inputs:\n        n - number of discrete elements to use in the model\n        p - packed parameters to create symbolic material and physical equations\n    \n    Outputs:\n        Symbolic, nolinear equations of motion for the discretized catheter model\n    \n    \"\"\"\n    #-------------------------------------------------\n    # Step 1: construct the catheter model\n    \n    # Generalized coordinates and velocities\n    # (in this case, angular positions & velocities of each mass) \n    q = mechanics.dynamicsymbols('q:{0}'.format(n))\n    u = mechanics.dynamicsymbols('u:{0}'.format(n))\n    \n    # Torques applied to each element due to external loads\n    Torque = dynamicsymbols('tau:{0}'.format(n))\n    \n    # Force applied at the end of the catheter by the user\n    F_in = dynamicsymbols('F:{0}'.format(1))\n\n    # Unpack the system values\n    M, L, E, I = p\n    \n    # Structural damping \n    damp = 0.05\n\n    # Assuming that the lengths and masses are evenly distributed \n    # (that is, the sytem is homogeneous), let's evenly divide the\n    # Lengths and masses along each discrete member\n    lengths = np.concatenate([np.broadcast_to(L / n,n)])    \n    masses = np.concatenate([np.broadcast_to(M / n,n)])\n\n    # time symbol\n    t = symbols('t')\n    \n    # The stiffness of the internal springs simulating material stiffness\n    stiffness = E * I\n    \n    #--------------------------------------------------\n    # Step 2: build the model using Kane's Method\n\n    # Create pivot point reference frame\n    A = mechanics.ReferenceFrame('A')\n    P = mechanics.Point('P')\n    P.set_vel(A,0)\n\n    # lists to hold particles, forces, and kinetic ODEs\n    # for each pendulum in the chain\n    particles = []\n    forces = []\n    kinetic_odes = []\n    \n    # Create a rotated reference frame for the first rigid link\n    Ar = A.orientnew('A' + str(0), 'axis', [q[0],A.z])\n\n    # Create a point at the center of gravity of the first link\n    Gr = P.locatenew('G' + str(0),(lengths[0] / 2) * Ar.x)\n    Gr.v2pt_theory(P,A,Ar)\n    \n    # Create a point at the end of the link\n    Pr = P.locatenew('P' + str(0), lengths[0] * Ar.x)\n    Pr.v2pt_theory(P, A, Ar)   \n\n    # Create the inertia for the first rigid link\n    Inertia_r = inertia(Ar,0,0,masses[0] * lengths[0]**2 / 12)\n\n    # Create a new particle of mass m[i] at this point\n    Par = mechanics.RigidBody('Pa' + str(0), Gr, Ar, masses[0], (Inertia_r,Gr))\n    particles.append(Par)\n    \n    # Add an internal spring based on Euler-Bernoulli Beam theory\n    forces.append((Ar, -stiffness * (q[0]) / (lengths[0]) * Ar.z))\n    \n    # Add a damping term\n    forces.append((Ar, (-damp * u[0]) * Ar.z))\n    \n    # Add a new ODE term\n    kinetic_odes.append(q[0].diff(t) - u[0])\n    \n    P = Pr\n    \n    for i in range(1,n):\n        \n        # Create a reference frame following the i^th link\n        Ai = A.orientnew('A' + str(i), 'Axis', [q[i],Ar.z])\n        Ai.set_ang_vel(A, u[i] * Ai.z)\n        \n        # Set the center of gravity for this link\n        Gi = P.locatenew('G' + str(i),lengths[i] / 2 * Ai.x)\n        Gi.v2pt_theory(P,A,Ai)\n\n        # Create a point in this reference frame\n        Pi = P.locatenew('P' + str(i), lengths[i] * Ai.x)\n        Pi.v2pt_theory(P, A, Ai)\n        \n        # Set the inertia for this link\n        Inertia_i = inertia(Ai,0,0,masses[i] * lengths[i]**2 / 12)\n\n        # Create a new particle of mass m[i] at this point\n        Pai = mechanics.RigidBody('Pa' + str(i), Gi, Ai, masses[i], (Inertia_i,Gi))\n        particles.append(Pai)\n        \n        # The external torques influence neighboring links\n        if i + 1 < n:\n            next_torque = 0\n            for j in range(i,n):\n                next_torque += Torque[j]\n        else:\n            next_torque = 0.\n            \n        forces.append((Ai,(Torque[i] + next_torque) * Ai.z))\n        \n        # Add another internal spring\n        forces.append((Ai, (-stiffness * (q[i] - q[i-1]) / (2 * lengths[i])) * Ai.z))\n        \n        # Add the damping term\n        forces.append((Ai, (-damp * u[i]) * Ai.z))\n\n        kinetic_odes.append(q[i].diff(t) - u[i])\n\n        P = Pi\n    \n    # Add the user-defined input at the tip of the catheter, pointing normal to the \n    # last element\n    forces.append((P, F_in[0] * Ai.y))\n\n    # Generate equations of motion\n    KM = mechanics.KanesMethod(A, q_ind=q, u_ind=u,\n                               kd_eqs=kinetic_odes)\n    fr, fr_star = KM.kanes_equations( particles, forces)\n\n    return KM, fr, fr_star, q, u, Torque, F_in, lengths, masses\n\ndef parameterize(n,kane):\n    \"\"\"\n    Parameterize the symbolic equations of motion so that they can be integrated \n    \n    Inputs:\n        n - number of elements\n        kane - full nonlinear equations of motion\n\n    Outputs: \n        mm_func - mass matrix function\n        fo_func - forcing matrix function\n    \"\"\"\n\n    # Unpack the kanes method parameters\n    KM, fr, fr_star, q, u, tau, force_in, lengths, masses = kane\n    \n    # define symbols for unknown parameters\n    unknowns = [Dummy() for i in q + u + tau + list(force_in)]\n    unknown_dict = dict(zip(q + u + tau + list(force_in), unknowns))\n    kds = KM.kindiffdict()\n\n    # substitute unknown symbols for qdot terms\n    mm_sym = KM.mass_matrix_full.subs(kds).subs(unknown_dict)\n    fo_sym = KM.forcing_full.subs(kds).subs(unknown_dict)\n\n    # create functions for numerical calculation \n    mm_func = lambdify(unknowns, mm_sym)\n    fo_func = lambdify(unknowns, fo_sym)\n\n    return mm_func,fo_func\n\ndef linearize_system(n,kane):\n    \"\"\"\n    Take the previously derived equations of motion and create an LTI model\n    \n    Inputs:\n        n - number of elements\n        kane - full nonlinear equations of motion\n        p - packed parameters (must have values)\n    \n    Outputs:\n        A_np - Linearized A matrix as a numpy array\n        B_np - Linearized B matrix as a numpy array\n    \"\"\"\n\n    # Unpack the kanes method parameters\n    KM, fr, fr_star, q, u, Torque, F_in, lengths, masses = kane\n\n    # Linearize the Kane's method equations\n    linearizer = KM.to_linearizer()\n    \n    # Output the A, B, and Mass matrices\n    Maz, A, B = linearizer.linearize()\n    \n    # Create an operating point around which we will linearize\n    op_point = dict()\n\n    # we will linearize about the undeflected, stationary point\n    for h in range(n):\n        op_point[q[h]] = 0.0\n        op_point[u[h]] = 0.0\n    \n    # Perform substitutions to solve for the linearized matrices\n    M_op = me.msubs(Maz, op_point)\n    A_op = me.msubs(A, op_point)\n    B_op = me.msubs(B, op_point)\n    perm_mat = linearizer.perm_mat\n\n    # Solve for the linear A and B matrices\n    A_lin = perm_mat.T * M_op.LUsolve(A_op)\n    B_lin = perm_mat.T * M_op.LUsolve(B_op)\n    A_sol = A_lin.subs(op_point).doit()\n    B_sol = B_lin.subs(op_point).doit()\n\n    # Ensure the matrices are of the correct data type\n    A_np = np.array(np.array(A_sol), np.float)\n    B_np = np.array(np.array(B_sol), np.float)\n\n    return A_np,B_np\n\ndef body_rotation(coords,angle):\n    \"\"\"\n    Rotate a body in a two-dimensional coordinate frame\n    \n    Inputs:\n        coords - [2xn] array of coordinates in the current frame\n        angle - [1xn] array of angles about which the frame is rotated\n    \n    Outputs:\n        x - X-coordinate in the rotated frame\n        y - Y-coordinate in the rotated frame\n    \"\"\"\n    \n    # Rotation about the z-axis\n    def R_z(theta):\n        rotation = np.zeros([len(theta),2,2])\n        rotation[:,0,0] = np.cos(theta)\n        rotation[:,0,1] = -np.sin(theta)\n        rotation[:,1,0] = np.sin(theta)\n        rotation[:,1,1] = np.cos(theta)\n        return rotation\n    \n    # Perform the rotation\n    rotated_coords = np.matmul(R_z(angle[:]), coords)\n    \n    # Extract the x and y coordinates\n    x = rotated_coords[:,0,0]\n    y = rotated_coords[:,1,0]\n\n    return x,y\n\n\ndef get_xy_coords(n,q, lengths):\n    \"\"\"\n    Get (x, y) coordinates of the beam from generalized coordinates q\n    \n    Inputs:\n        n - number of elements\n        q - generalized coordinates\n        lengths - length of each element\n    \n    Outputs:\n        x_coords - X-coordinates of each beam element\n        y_coords - Y-coordinates of each beam element\n    \"\"\"\n    \n    q = np.atleast_2d(q)\n    \n\n    zeros = np.zeros(q.shape[0])[:, None]\n    x = np.hstack([zeros])\n    y = np.hstack([zeros])\n\n    for i in range(0,n):\n        \n        # Get the new x and y coordinates to append \n        x_app,y_app = body_rotation(np.array([[lengths[i]],[0]]),q[:,i])\n        \n        # Append to the matrices\n        x = np.append(x,np.atleast_2d(x_app).T,axis=1)\n        y = np.append(y,np.atleast_2d(y_app).T,axis=1)\n    \n    x_coords = np.cumsum(x,1)\n    y_coords = np.cumsum(y,1) \n\n    return x_coords, y_coords\n\ndef get_xy_deriv(n,q, lengths):\n    \"\"\"\n    Get (x_dot, y_dot) coordinates from generalized coordinates q\n\n    Inputs:\n        n - number of elements\n        q - generalized coordinates\n        lengths - length of each element\n    \n    Outputs:\n        x_dot_coords - X_dot-coordinates of each beam element\n        y_dot_coords - Y_dot-coordinates of each beam element\n    \n    \"\"\"\n    \n    q = np.atleast_2d(q)\n\n    zeros = np.zeros(q.shape[0])[:, None]\n    x_dot = np.hstack([zeros])\n    y_dot = np.hstack([zeros])\n\n    # Do this for each element\n    for i in range(0,n):\n    \n        # Get the new x_dot and y_dot coordinates to append\n        x_app = -lengths[i] * np.sin(q[:,i]) * q[:,i + (n)]\n        y_app = lengths[i] * np.cos(q[:,i]) * q[:,i + (n)]\n        \n        x_dot = np.append(x_dot,np.atleast_2d(x_app).T,axis=1)\n        y_dot = np.append(y_dot,np.atleast_2d(y_app).T,axis=1)\n\n    x_dot_coords = np.cumsum(x_dot,1)\n    y_dot_coords=  np.cumsum(y_dot,1)\n \n    return x_dot_coords,y_dot_coords\n\ndef force(coords,r,time):\n    ''' \n    Get the force resulting from flow on a cylinder in two dimensions\n    \n    Inputs:\n        Coords - location of the current element in the global coordinate frame\n        r - displacement vector from the origin of the element\n        time - current time \n    \n    Outputs:\n        F - [2x1] array containing X and Y forces in the reference coordinate frame\n    '''\n    \n    # Maximum velocity of the flow field in m/s\n    flow_amp = 0.5\n    \n    # Flow field velocity\n    u_y = flow_amp * np.cos(1. * np.pi * time) + flow_amp # m/s\n    \n    #  Drag coefficient\n    Cd = 1.2 \n    \n    # Mass density of blood\n    rho_blood = 1060 # kg/m^3\n    \n    # Diameter of the catheter\n    Diam = 2.667e-3 # m\n    \n    # Length projected into the X-axis\n    projected_length = r[0]\n    \n    # Drag force\n    F_dy = 0.5 * u_y * rho_blood * Cd * Diam * projected_length\n    \n    # Ignoring forces in the x-direction for now\n    f_x = 0.\n\n    return np.array([[f_x],[F_dy]])\n\ndef get_forces(n,q,lengths,time=0.):\n    \"\"\"\n    Get the resulting torques acting on the catheter at this instant in time\n    \n    Inputs:\n        n - number of elments\n        q - generalized coordinates\n        lengths - lengths of each elements\n        time - current time in the simulation\n    \n    Outputs:\n        tau - torques along each hinge in the Z direction\n    \"\"\"\n    \n    # Get the x and y coordinates of the beam\n    x,y = get_xy_coords(n,q,lengths)\n\n    # For each origin point of each link, integrate the cross product of the \n    # position vector for the link with the  force converted into the link frame.\n    # Return the torques in a way that can be added to the state variables when\n    # integrating\n\n    tau = np.zeros(n)\n    \n    # for each element\n    for i in range(n):\n        \n        # Get the displacement of this element\n        angles = np.atleast_2d(q[i])\n        \n        # Because we want to rotate from the global coordinate frame into \n        # the local frame for each element, we will use the negative rotation\n        # angle in our calculations\n        angles = -angles\n\n        frame_origin = np.array([[x[0,i]],\n                                 [y[0,i]]])\n\n        # Direction vector pointing along the X-direction of the desired link\n        # This vector is defined in the global coordinate frame\n        r = np.array([[x[0,i] - x[0,i-1]],\n                      [y[0,i] - y[0,i-1]]])\n\n        # Unit vector pointing in the direction aligned with the link\n        # This vector is divided by L, which is the magnitude of r\n        u = r / lengths[i]\n        \n        # Get the projected force on the element at position \"x\"\n        proj_force = lambda x: body_rotation(force(x * u + frame_origin,r,time),angles)\n        \n        # Compute the torque applied by the force at position \"x\"\n        torquez = lambda x: np.cross(np.array([x,0]),np.array([proj_force(x)]).flatten())\n        \n        # The total torque applied to the element is the integral of the torque\n        # across its length\n        torques = np.array([integrate.quad(torquez,0,lengths[i])[0]])\n\n        tau[i] = torques\n        \n    return tau\n\ndef nonlinear_response(n,args,funcs,control_args):\n    \"\"\"\n    Create a response from the nonlinear equations of motion\n    \n    Inputs:\n        n - number of elements\n        args - response-specific arguments\n            f_max - maximum force allowed by the actuator\n            time - time array for the simulation\n            X0 - initial values for the catheter model\n            y_desired - desired tip location for the y-coordinate \n        funcs - nonlinear parameterized functions\n            mm_func - mass matrix function\n            fo_func - forcing matrix function\n        control_args - arguments regarding control\n            Kp - proportional gain\n            Kd - derivative gain\n            use_control - option to use PD control or let the catheter move uncontrolled\n    \n    Outputs:\n        response - integrated equations of motion\n    \"\"\"\n    \n    # Unpack arguments\n    f_max, time, X0, y_desired,lengths = args\n    kp,kd,use_control = control_args\n    mm_func,fo_func = funcs\n   \n    # Define the initial conditions\n    q_i = np.array(X0[:n])\n    u_i = np.array(X0[n:])\n\n    # initial positions and velocities – assumed to be given in degrees\n    y0 = np.concatenate([np.tile(q_i,n),np.tile(u_i,n)])\n    \n    tau = np.zeros(n)\n    force_in = np.zeros(1)\n    \n    # function which computes the derivatives of parameters\n    def gradient(x, currtime,t_sys,tau,force_in):\n        \n        # Use this option to show a controlled or uncontrolled catheter\n        if use_control:\n            \n            # Get the current x and y coordinates of the catheter\n            curr_x,curr_y = get_xy_coords(n,x,lengths)\n            curr_x_dot,curr_y_dot = get_xy_deriv(n,x,lengths)\n\n            # Use proportional-Derivative control on the tip y-coordinate\n            force_in[0] = kp * (y_desired - curr_y[0,-1]) + kd * (0 - curr_y_dot[0,-1])\n        else:\n            force_in[0] = 0.\n        \n        # Get forces from the external disturbance\n        tau = get_forces(n,x,lengths,currtime)\n        \n        # Solve the equations at this time step\n        vals = np.concatenate((x, tau, force_in))\n        sol = np.linalg.solve(mm_func(*vals), fo_func(*vals))\n\n        return np.array(sol).T[0]\n\n    return odeint(gradient, y0, time, args=(time,tau, force_in))\n\ndef linear_response(n,A,B,args,control_args):\n    \"\"\"\n    Create a response from the linear equations of motion\n    \n    Inputs:\n        n - number of elements\n        A - A matrix for the linear equations of motion\n        B - B matrix for the linear equations of motion\n        args - response-specific arguments\n            f_max - maximum force allowed by the actuator\n            time - time array for the simulation\n            X0 - initial values for the catheter model\n            y_desired - desired tip location for the y-coordinate \n        control_args - arguments regarding control\n            Kp - proportional gain\n            Kd - derivative gain\n            use_control - option to use PD control or let the catheter move uncontrolled\n    \n    Outputs:\n        response - integrated equations of motion\n    \"\"\"\n    \n    # Unpack arguments\n    f_max, time, X0, y_desired,lengths = args\n    kp,kd,use_control = control_args\n\n    # Create the initial conditions\n    q_i = np.array(X0[:n])\n    u_i = np.array(X0[n:])\n\n    # initial positions and velocities – assumed to be given in degrees\n    y0 = np.concatenate([np.tile(q_i,n),np.tile(u_i,n)])\n    \n    tau = np.zeros(n)\n    force_in = np.zeros(B.shape[1])\n\n    # function which computes the derivatives of parameters\n    def gradient(x, currtime, t_sys):\n\n        # Use this option to show a controlled or uncontrolled catheter\n        if use_control:\n            \n            # Get the current x and y coordinates of the catheter\n            curr_x,curr_y = get_xy_coords(n,x,lengths)\n            curr_x_dot,curr_y_dot = get_xy_deriv(n,x,lengths)\n\n            # Use proportional-Derivative control on the tip y-coordinate\n            force_in[0] = kp * (y_desired - curr_y[0,-1]) + kd * (0 - curr_y_dot[0,-1])\n        else:\n            force_in[0] = 0.\n        \n        # Get torques from the external disturbance\n        tau = get_forces(n,x,lengths,currtime)\n        \n        # apply the external torques to the input vector\n        force_in[1:] = tau[1:]\n       \n        # Solve the equation of motion\n        sol = np.matmul(A,x) + np.matmul(B,force_in)\n        \n        return np.array(sol)\n\n    return odeint(gradient, y0, time, args=((time,)))",
			"file": "code/mypackage/catheter_utils.py",
			"file_size": 18032,
			"file_write_time": 131697684300015808,
			"settings":
			{
				"buffer_size": 18041,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/LaTeXTools/LaTeX.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					""
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Traditional"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Script Builder"
				]
			],
			[
				"Packages/LaTeXTools/LaTeX.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					""
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Traditional"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Script Builder"
				],
				[
					"Packages/User/Latex.sublime-build",
					""
				]
			],
			[
				"Packages/LaTeXTools/LaTeX.sublime-build",
				"PdfLaTeX"
			]
		],
		[
			[
				[
					"Packages/LaTeXing/LaTeX (TikZ).sublime-build",
					""
				],
				[
					"Packages/LaTeXing/LaTeX (TikZ).sublime-build",
					"Clean up Files"
				]
			],
			[
				"Packages/LaTeXing/LaTeX (TikZ).sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/LaTeXing/LaTeX.sublime-build",
					""
				],
				[
					"Packages/LaTeXing/LaTeX.sublime-build",
					"Clean up Files"
				]
			],
			[
				"Packages/LaTeXing/LaTeX.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/LaTeXing/LaTeX.sublime-build",
					""
				],
				[
					"Packages/LaTeXing/LaTeX.sublime-build",
					"Clean up Files"
				],
				[
					"Packages/User/Bibtext.sublime-build",
					""
				]
			],
			[
				"Packages/User/Bibtext.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/User/markdown-to-pdf.sublime-build",
					""
				],
				[
					"Packages/User/Markdown_To_PDF.sublime-build",
					""
				]
			],
			[
				"Packages/User/Markdown_To_PDF.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/User/markdown-to-pdf.sublime-build",
					""
				],
				[
					"Packages/User/Markdown_To_PDF.sublime-build",
					""
				],
				[
					"Packages/User/PDF.sublime-build",
					""
				],
				[
					"Packages/User/PDF_1.sublime-build",
					""
				],
				[
					"Packages/User/PDF_1.sublime-build",
					"Markdown to latex"
				],
				[
					"Packages/User/PDF_1.sublime-build",
					"Run"
				]
			],
			[
				"Packages/User/Markdown_To_PDF.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 329.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"pandoc",
				"Pandoc"
			],
			[
				"latex",
				"LaTeXTools: Check system"
			],
			[
				"pan",
				"Pandoc"
			],
			[
				"",
				"Set Syntax: MultiMarkdown"
			],
			[
				"packag",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Install Package"
			],
			[
				"Package Control: ",
				"Package Control: Remove Package"
			],
			[
				"package",
				"Package Control: Install Package"
			],
			[
				"pdf",
				"Pandoc: Convert a Pandoc file to PDF"
			],
			[
				"pa",
				"Pandoc: Convert a Pandoc file to PDF"
			],
			[
				"syntax",
				"Set Syntax: Markdown"
			],
			[
				"spandoc",
				"Spandoc: Palette"
			],
			[
				"PACKA",
				"Package Control: Install Package"
			],
			[
				"mdpd",
				"Build With: markdown-to-pdf"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"INSTALL",
				"Package Control: Install Package"
			],
			[
				"package control: add ",
				"Package Control: Add Repository"
			],
			[
				"latextools",
				"LaTeXTools: Reset user settings to default"
			],
			[
				"package Control",
				"Package Control: Install Package"
			]
		],
		"width": 412.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/dnewman/Documents/Github/Catheter-Ablation",
		"/home/dnewman/Documents/Github/Catheter-Ablation/code",
		"/home/dnewman/Documents/Github/Catheter-Ablation/code/mypackage",
		"/home/dnewman/Documents/Github/Catheter-Ablation/code/notebooks",
		"/home/dnewman/Documents/Github/Catheter-Ablation/data",
		"/home/dnewman/Documents/Github/Catheter-Ablation/results"
	],
	"file_history":
	[
		"/usr/share/X11/xorg.conf.d/60-logitech-m510.conf",
		"/usr/share/X11/xorg.conf.d/60.synaptics.conf",
		"/usr/share/X11/xorg.conf.d/70.synaptics.conf",
		"/home/dnewman/Documents/research-literature/Documents/Research/Controls/Emailing Dorf & Bishop Modern Control Systems 12th c2011 txtbk.pdf",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/thesis.tex",
		"/home/dnewman/Documents/Github/UL-Lafayette-Thesis-Template/UL_Lafayette_Template/ULL_thesis_template.tex",
		"/home/dnewman/Documents/Github/UL-Lafayette-Thesis-Template/README.md",
		"/home/dnewman/Documents/Github/Catheter-Ablation/README.md",
		"/home/dnewman/Documents/Github/Catheter-Ablation/.gitignore",
		"/home/dnewman/Documents/Github/Catheter-Ablation/manuscript/manuscript.tex",
		"/home/dnewman/Documents/Github/Catheter-Ablation/code/README.md",
		"/home/dnewman/Documents/Github/Personal-Code/Professional-Resume/Latex/resume.tex",
		"/home/dnewman/Documents/Github/Catheter-Ablation/results/README.md",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/gatech-thesis.cls",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/epigraph.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/ULL-style.sty",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter2.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter3.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter4.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Conference Papers/CCTA - Nonzero Shaping Boom Crane - 2017/CCTA_NonzeroShapingBoomCrane_2017.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/dedication.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/biosketch.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter1.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Conference Papers/ACC_RobustIC_2018/ACC_RobustIC_2018.tex",
		"/home/dnewman/Documents/Github/Catheter-Ablation/code/mypackage/catheter_utils.py",
		"/home/dnewman/Documents/Github/UL-Lafayette-Thesis-Template/UL_Lafayette_Template/chapter1.tex",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Conference Papers/CCTA - Nonzero Shaping Boom Crane - 2017/bibliography.bib",
		"/home/dnewman/Documents/Github/Angular-Tinkering/Angular-test/app/view2/view2.html",
		"/home/dnewman/Documents/Github/Catheter-Ablation/code/setup.py",
		"/home/dnewman/Documents/Github/Catheter-Ablation/environment.yml",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Papers/ACC_RobustIC_2018/.gitignore",
		"/home/dnewman/Documents/Github/CRAWLAB-Student-Code/Daniel Newman/Papers/Catheter_Ablation/ACC_RobustIC_2018.sublime-project",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Papers/ACC_RobustIC_2018/environment.yml",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Papers/ACC_RobustIC_2018/manuscript/manuscript.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Papers/ACC_RobustIC_2018/code/setup.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Papers/ACC_RobustIC_2018/manuscript/Makefile",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Cardiac Project/Simple_Modeling/2d_beam.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Papers/ACC_RobustIC_2018/README.md",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Conference Papers/ACC_RobustIC_2018/ACC_RobustIC_2018.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/plot_response_exp.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Python Modules/ic_impulse.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/overlay_videos.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Python Modules/ic_linear.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Cardiac Project/Simple_Modeling/A_Matrix.npy",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter4.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/exp_Sens.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/track_cherrypicker.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/show_cherrypicker_pin.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Simulate_Sens.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Python Modules/Generate_Plots.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/sim_sens.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/input_gen.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/InitialCondition/create_siic_shaper.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/record_camera_live.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Amplitudes_0.35m/Unshaped_4deg.csv",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/plot_abs_amps_expvssim.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/input_gen_track_cherrypicker.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Data/Amplitudes/SI-IC_4deg.csv",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Korea/create_siic_shaper.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Python Modules/Boom_Crane.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Data/Amplitudes/Unshaped_4deg.csv",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Data/Amplitudes/ZV-IC_4deg.csv",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Cardiac Project/Simple_Modeling/beam_model.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/Concurrent/twolink_LQR.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/Concurrent/twolink_optimized.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter3.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Amplitudes/SI-IC_4deg.csv",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Amplitudes/Unshaped_4deg.csv",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/DSCC_BoomCrane_2018/Amplitudes/ZV-IC_4deg.csv",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/Concurrent/lqr_optimized_crane.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/simple_crane_trapezoidal.py",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/view1/view1.html",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/view1/css/flexslider.css",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/view3/view3.html",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/app.js",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/index.html",
		"/Users/daniel/Github/Personal-Code/Node_Tests/app.js",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/view3/view3_test.js",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/view3/view3.js",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/index-async.html",
		"/Users/daniel/Github/Personal-Code/CV Resume Cover Letter/Cover Letters/L3 Technologies/cover_letter.tex",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/view1/css/main.css",
		"/Users/daniel/Github/Personal-Code/angular-seed/app/view1/css/normalize.css",
		"/Users/daniel/Github/Personal-Code/CV Resume Cover Letter/Cover Letters/SpaceX/Cover Letter.tex",
		"/Users/daniel/Github/CRAWLAB-Code-Review/20180318_Newman_CraneAnimation/Readme.md",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/BoomCrane/record_link_vibration.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/InitialCondition/pulse_vs_impulse_example.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/crane_anim.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/BoomCrane/plot_3d_bc_pulse.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/input_gen.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/BoomCrane/overlay_videos.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/Concurrent/smooth_shaping.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/IC_Journal/plot_damped_impulse_variation.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Proposals/CV Resume Cover Letter/Cover Letters/SpaceX/Cover Letter.tex",
		"/Users/daniel/Github/Personal-Code/CV Resume Cover Letter/Cover Letters/Blue Origin/Cover Letter.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Proposals/CV Resume Cover Letter/Cover Letters/Blue Origin/Cover Letter.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Proposals/CV Resume Cover Letter/Professional Resume/Latex/resume.pdf",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Proposals/CV Resume Cover Letter/Professional Resume/Latex/resume.tex",
		"/Users/daniel/Github/Thesis-Notebooks/Styling/IpythonNotebook.css",
		"/Users/daniel/Google Drive/MSME/ENGR 640/Reading Response/Measure/Measure.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/Chapter_1/simple_crane_step.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Experimental_Hardware/Aerial_Lift/overlay_videos.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Python Modules/Class_Plots.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/Sensitivity_Plots/sens.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/simple_oscillator.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/BoomCrane/BC_IC.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Animations/load_image.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/For_Presentation/nonzero_hoist.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Python Modules/si.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Korea/plot_exp_impulse_vs_sim.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter6.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter2.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter5.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/thesis.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/Chapter_1/simple_crane_trapezoidal.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/BoomCrane/IC_Shaping.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/InitialCondition/impulse_vs_pulse.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/DisturbedBoomCrane/disturbed_IC.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/acknowledgements.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/BoomCrane/Data/bc_imp_amp_low.txt",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/IC_Journal/Plot_Pulse_response.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Python Modules/kanes_2link.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/chapter1.tex",
		"/Users/daniel/Google Drive/MSME/ENGR 640/Term Paper/simple_crane_step.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Thesis/Daniel_Thesis_2018/dedication.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/Concurrent/sensitivity_crane.py",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Research/Working Documents/Cardiac Project/Control Review/Control_Review.tex",
		"/Users/daniel/Github/CRAWLAB-Student-Code/Daniel Newman/Code/Paper_Simulations/Thesis/InitialCondition/Pulse_Response_Simulation.py"
	],
	"find":
	{
		"height": 28.0
	},
	"find_in_files":
	{
		"height": 101.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			" = ",
			"lastnamefirstname",
			"firsnamelastname",
			"time domain design",
			"figurename",
			"caption",
			"fig",
			"figure",
			"lastnamefirstname",
			"acknowledgments",
			"  ",
			"dedication",
			"step_response_approx",
			"table",
			"plot_data",
			"transparent=True",
			"TROLLEY_IMAGE",
			"trolley_offset_Y",
			"trolley_offset_x",
			"mpl",
			"plt",
			"time",
			"starttime",
			";",
			"sensplot",
			"dual_plot",
			"dual_label",
			"theta",
			"STEP_INPUT",
			"compare_scatter",
			"EI",
			"ORIGN_OFFSET",
			"second-order",
			"the bode plot",
			"highly damped",
			"due to limited ",
			"this crane consists",
			"the S-Curve command almost",
			"higher closed-loop",
			"high mode",
			"this discontinuous control",
			"this discontinuous contorl input",
			"this discontinuous",
			"in fact, eliminating",
			"this effect is evident",
			"eq:LQRcost",
			"eq:linss",
			"eq:SI-IC",
			"omega_n",
			"omegan",
			"omega_n",
			"shiftedresponse",
			"sec:model",
			"Their responses at the designed",
			"the data in this figure",
			"lqr shaped response",
			"$V_{max}$ by accelerating",
			"V_{max} by accelerating",
			"time optimal",
			"time optimal solutions",
			"its insensitivity of ",
			"example shaped response",
			"example response",
			"is the disturbance frequency",
			"while the ZV-LE shaper",
			"opencv",
			"serve as a small scale",
			"the revised approximation",
			"because the superposed approximation",
			"deviates by",
			"benchmark system experimental",
			"plot_3d",
			"barring",
			"plot_3d",
			"compare_scatter",
			"the proposed shaping methods",
			"regardless of the enforced",
			"conversely, the amplitude",
			"the expression for a",
			"the general procedure",
			"second order",
			"to that of a linear",
			"\\gamma_{dot}<",
			"\\gamma_{dot} <",
			"\\gamma_{dot} <<",
			"the output from the plant",
			"the ZV and EI",
			"zero vibration derivative",
			"second order",
			"\\textcolor",
			"zv_2mode",
			"rejecting disturbances to",
			"while neither",
			"on the other hand",
			"on the other hadn",
			"if a maximum ",
			"Figure.",
			"    ",
			"low_effort_shaper",
			"zetas",
			"omegas",
			"zetas",
			"omegas",
			"seqconv",
			"t_step",
			"zetas",
			"Omegas",
			"linearize_system",
			"\\frac{\\omega}{\\omega}",
			"\\tau_{acc}",
			"\\tau_acc",
			"\\tauacc",
			"this scaling factor is configur",
			"the moderate nonlinearity",
			"beating",
			"as a result of the ",
			"this zv shaper introduces approximately",
			"this plot is consistent with the previous",
			"resulting in a normalized insensitivity",
			"for a shaper with specified insensitivity",
			"the oscillation amplitude due to",
			"this normalized acceleration time",
			"if the shaped command and the reference",
			"a sequence of impulses",
			"because actuator bandwidth",
			"the controller impulses",
			"recently some research",
			"Figs."
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"zvic",
			"siic_7",
			"siic_6",
			"siic_5",
			"siic_4",
			"siic_3",
			"siic_2"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "code/mypackage/catheter_utils.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18041,
						"regions":
						{
						},
						"selection":
						[
							[
								4727,
								4727
							]
						],
						"settings":
						{
							"git_savvy.repo_path": "/home/dnewman/Documents/Github/Catheter-Ablation",
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1881.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 28.0
	},
	"input":
	{
		"height": 35.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 100.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.latextools":
	{
		"height": 134.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/LaTeXTools/LaTeX.sublime-build",
	"project": "Catheter_2018.sublime-project",
	"replace":
	{
		"height": 52.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 692.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 306.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
